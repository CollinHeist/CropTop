/* **************************************************************************
 * File name:   MotorLib.c
 * Association: University of Idaho
 * Author:      Ryan Donahue
 * Dates:       Created 1/9/2018
 * 
 * Summary:     This file contains a collection of functions and macros used to 
 *              enable the TI DRV8872DDAR motor driver. The device operates via
 *              PWM signal generated by output compare module 1 and GPIO. In the 
 *              event of over current or thermal overload the chip generates a 
 *              motor fault interrupt.
 * 
 * Notes:       Software things:
 *              -The toggles per second macro needs to be calibrated for the new 
 *               clock rate.
 *
 *              Hardware things:
 *              -Looks like the nFault pin should have a pullup resistor datasheet says
 *               "high-z when operating normal, low during a fault"
 *              -Add in a sense resistor to prevent overcurrent
 *              -Fix the CN15 label on pin 82 to say "CN14"
 * **************************************************************************/

//includes and definitions
#define _SUPPRESS_PLIB_WARNING
#include <plib.h>

//macros
#define GetSystemClock()		(80000000ul)            //80 MHz
#define GetPeripheralClock()	(GetSystemClock()/1)
#define TOGGLES_PER_SEC 0x9C40                          //timer setup
#define PBCLK GetPeripheralClock()                      //peripheral bus clock
#define PWM_CYCLE_FREQUENCY 1000                        //pwm cycle frequency
#define PWM_CYCLE_COUNT (PBCLK/(PWM_CYCLE_FREQUENCY)    //cycle count
#define PR2_VALUE (PWM_CYCLE_COUNT-1)                   //period register value
#define nFAULT (0x01<<5)                                //port D
#define IN1 (0x01<<1)                                   //port D
#define IN2 (0x01<<2)                                   //port D

void MotorLib_Init()
{
    //enable GPIO
    MotorLib_GPIOSetup();
    //enable the timers used by the module
    MotorLib_TimersSetup();
    //enable the output compare peripheral
    MotorLib_OCSetup();
    //enable the fault indicator interrupt
    MotorLib_CNInterruptSetup();
}

void MotorLib_GPIOSetup()
{
    //output compare module pins
    PORTSetPinsDigitalOut(IOPORT_D, (IN1 | IN2)); 
    //driver fault change notice interrupt pin
    PORTSetPinsDigitalIn(IOPORT_D, nFAULT);
}

void MotorLib_TimersSetup()
{
    //timer 2 generates interrupt once each mS.
    OpenTimer2((T2_ON | T2_PS_1_1), TOGGLES_PER_SEC);
    //set timer priority group to 2, subgroup 0
    mT2SetIntPriority(2);
    mT2SetIntSubPriority(0);
    mT2ClearIntFlag();
    mT2IntEnable(1);
}

void __ISR(_TIMER_2_VECTOR, IPL2) Timer2Handler(void)
{
    mT2ClearIntFlag();
}

void MotorLib_OCSetup()
{
    //initial values
    int nOCRS = 0; //0% duty cycle
    int nOCR = nOCRS;
    //output compare 2
    OpenOC2(OC_ON|OC_TIMER_MODE16|OC_TIMER2_SRC|OC_PWM_FAULT_PIN_DISABLE, nOCRS, nOCR);    
    //output compare 3
    OpenOC3(OC_ON|OC_TIMER_MODE16|OC_TIMER2_SRC|OC_PWM_FAULT_PIN_DISABLE, nOCRS, nOCR);
}

int MotorLib_DutyCycleSet(unsigned int C2DutyCycle, unsigned int C3DutyCycle)
{
    //calculate the new PWM register values
    int new_nOC2RS = (C2DutyCycle * (PR2_VALUE+1))/100);
    int new_nOC3RS = (C3DutyCycle * (PR2_VALUE+1))/100);
    //change the PWM setting
    SetDCOC2PWM(new_nOC2RS);
    SetDCOC3PWM(new_nOC3RS);
}

void MotorLib_CNInterruptSetup()
{
    //variable for dummy read
    unsigned int dummy;    
    //enable CN14 for pin 82
    mCNOpen(CN_ON, CN14_ENABLE, 0);
    //set priority levels group level 1, subgroup 0
    mCNSetIntPriority(1);
    mCNSetIntSubPriority(0);
    //read port to clear difference
    dummy = PORTReadBits(IOPORT_D, nFAULT);
    //clear flag and enable interrupt
    mCNClearIntFlag();
    mCNIntEnable(1);
}

void __ISR(_CHANGE_NOTICE_VECTOR, IPL1) CNIntHandler(void)
{
    //delay for a few ms
    
    //check that it was a motor fault
    if(PORTReadBits(IOPORT_D, nFAULT))
    {
        //flick a light or ideally trigger a semaphore that unblocks a warning
        //screen task
    }
}

void MotorLib_Forward(unsigned int speed)
{
    MotorLib_DutyCycleSet(speed, 0);
}

void MotorLib_Reverse(unsigned int speed)
{
    MotorLib_DutyCycleSet(0, speed);
}

void MotorLib_Idle()
{
    MotorLib_DutyCycleSet(0, 0);
}

void MotorLib_Brake()
{
    MotorLib_DutyCycleSet(100, 100);
}